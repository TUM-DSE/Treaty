// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3016000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3016000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
namespace tutorial {
class ClientMessageReq;
struct ClientMessageReqDefaultTypeInternal;
extern ClientMessageReqDefaultTypeInternal _ClientMessageReq_default_instance_;
class ClientMessageResp;
struct ClientMessageRespDefaultTypeInternal;
extern ClientMessageRespDefaultTypeInternal _ClientMessageResp_default_instance_;
class DataMessageReq;
struct DataMessageReqDefaultTypeInternal;
extern DataMessageReqDefaultTypeInternal _DataMessageReq_default_instance_;
class DataMessageResp;
struct DataMessageRespDefaultTypeInternal;
extern DataMessageRespDefaultTypeInternal _DataMessageResp_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Statement;
struct StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
}  // namespace tutorial
PROTOBUF_NAMESPACE_OPEN
template<> ::tutorial::ClientMessageReq* Arena::CreateMaybeMessage<::tutorial::ClientMessageReq>(Arena*);
template<> ::tutorial::ClientMessageResp* Arena::CreateMaybeMessage<::tutorial::ClientMessageResp>(Arena*);
template<> ::tutorial::DataMessageReq* Arena::CreateMaybeMessage<::tutorial::DataMessageReq>(Arena*);
template<> ::tutorial::DataMessageResp* Arena::CreateMaybeMessage<::tutorial::DataMessageResp>(Arena*);
template<> ::tutorial::Message* Arena::CreateMaybeMessage<::tutorial::Message>(Arena*);
template<> ::tutorial::Request* Arena::CreateMaybeMessage<::tutorial::Request>(Arena*);
template<> ::tutorial::Statement* Arena::CreateMaybeMessage<::tutorial::Statement>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tutorial {

enum Message_Type : int {
  Message_Type_HelloMessage = 1,
  Message_Type_GoodbyeMessage = 2,
  Message_Type_ClientReqMessage = 4,
  Message_Type_ClientRespMessage = 5,
  Message_Type_DataReqMessage = 101,
  Message_Type_DataRespMessage = 102
};
bool Message_Type_IsValid(int value);
constexpr Message_Type Message_Type_Type_MIN = Message_Type_HelloMessage;
constexpr Message_Type Message_Type_Type_MAX = Message_Type_DataRespMessage;
constexpr int Message_Type_Type_ARRAYSIZE = Message_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Message_Type_descriptor();
template<typename T>
inline const std::string& Message_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Message_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Message_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Message_Type_descriptor(), enum_t_value);
}
inline bool Message_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Message_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Message_Type>(
    Message_Type_descriptor(), name, value);
}
enum Statement_Type : int {
  Statement_Type_READ = 1,
  Statement_Type_WRITE = 2,
  Statement_Type_DELETE = 3,
  Statement_Type_READ_FOR_UPDATE = 4,
  Statement_Type_DUMMY = 5
};
bool Statement_Type_IsValid(int value);
constexpr Statement_Type Statement_Type_Type_MIN = Statement_Type_READ;
constexpr Statement_Type Statement_Type_Type_MAX = Statement_Type_DUMMY;
constexpr int Statement_Type_Type_ARRAYSIZE = Statement_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Statement_Type_descriptor();
template<typename T>
inline const std::string& Statement_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Statement_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Statement_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Statement_Type_descriptor(), enum_t_value);
}
inline bool Statement_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Statement_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Statement_Type>(
    Statement_Type_descriptor(), name, value);
}
enum ClientMessageResp_RespType : int {
  ClientMessageResp_RespType_REGISTER = 1,
  ClientMessageResp_RespType_OPERATION = 2,
  ClientMessageResp_RespType_TERMINATE = 3
};
bool ClientMessageResp_RespType_IsValid(int value);
constexpr ClientMessageResp_RespType ClientMessageResp_RespType_RespType_MIN = ClientMessageResp_RespType_REGISTER;
constexpr ClientMessageResp_RespType ClientMessageResp_RespType_RespType_MAX = ClientMessageResp_RespType_TERMINATE;
constexpr int ClientMessageResp_RespType_RespType_ARRAYSIZE = ClientMessageResp_RespType_RespType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClientMessageResp_RespType_descriptor();
template<typename T>
inline const std::string& ClientMessageResp_RespType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientMessageResp_RespType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientMessageResp_RespType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClientMessageResp_RespType_descriptor(), enum_t_value);
}
inline bool ClientMessageResp_RespType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientMessageResp_RespType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClientMessageResp_RespType>(
    ClientMessageResp_RespType_descriptor(), name, value);
}
enum Request_ReqType : int {
  Request_ReqType_READ = 1,
  Request_ReqType_WRITE = 2,
  Request_ReqType_DELETE = 3
};
bool Request_ReqType_IsValid(int value);
constexpr Request_ReqType Request_ReqType_ReqType_MIN = Request_ReqType_READ;
constexpr Request_ReqType Request_ReqType_ReqType_MAX = Request_ReqType_DELETE;
constexpr int Request_ReqType_ReqType_ARRAYSIZE = Request_ReqType_ReqType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Request_ReqType_descriptor();
template<typename T>
inline const std::string& Request_ReqType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Request_ReqType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Request_ReqType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Request_ReqType_descriptor(), enum_t_value);
}
inline bool Request_ReqType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Request_ReqType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Request_ReqType>(
    Request_ReqType_descriptor(), name, value);
}
// ===================================================================

class Message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit constexpr Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(nullptr);
  }

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Message_Type Type;
  static constexpr Type HelloMessage =
    Message_Type_HelloMessage;
  static constexpr Type GoodbyeMessage =
    Message_Type_GoodbyeMessage;
  static constexpr Type ClientReqMessage =
    Message_Type_ClientReqMessage;
  static constexpr Type ClientRespMessage =
    Message_Type_ClientRespMessage;
  static constexpr Type DataReqMessage =
    Message_Type_DataReqMessage;
  static constexpr Type DataRespMessage =
    Message_Type_DataRespMessage;
  static inline bool Type_IsValid(int value) {
    return Message_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Message_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Message_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Message_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Message_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Message_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Message_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClientReqMsgFieldNumber = 3,
    kClientRespMsgFieldNumber = 4,
    kDataReqMsgFieldNumber = 101,
    kDataRespMsgFieldNumber = 102,
    kMessageTypeFieldNumber = 1,
  };
  // optional .tutorial.ClientMessageReq clientReqMsg = 3;
  bool has_clientreqmsg() const;
  private:
  bool _internal_has_clientreqmsg() const;
  public:
  void clear_clientreqmsg();
  const ::tutorial::ClientMessageReq& clientreqmsg() const;
  ::tutorial::ClientMessageReq* release_clientreqmsg();
  ::tutorial::ClientMessageReq* mutable_clientreqmsg();
  void set_allocated_clientreqmsg(::tutorial::ClientMessageReq* clientreqmsg);
  private:
  const ::tutorial::ClientMessageReq& _internal_clientreqmsg() const;
  ::tutorial::ClientMessageReq* _internal_mutable_clientreqmsg();
  public:
  void unsafe_arena_set_allocated_clientreqmsg(
      ::tutorial::ClientMessageReq* clientreqmsg);
  ::tutorial::ClientMessageReq* unsafe_arena_release_clientreqmsg();

  // optional .tutorial.ClientMessageResp clientRespMsg = 4;
  bool has_clientrespmsg() const;
  private:
  bool _internal_has_clientrespmsg() const;
  public:
  void clear_clientrespmsg();
  const ::tutorial::ClientMessageResp& clientrespmsg() const;
  ::tutorial::ClientMessageResp* release_clientrespmsg();
  ::tutorial::ClientMessageResp* mutable_clientrespmsg();
  void set_allocated_clientrespmsg(::tutorial::ClientMessageResp* clientrespmsg);
  private:
  const ::tutorial::ClientMessageResp& _internal_clientrespmsg() const;
  ::tutorial::ClientMessageResp* _internal_mutable_clientrespmsg();
  public:
  void unsafe_arena_set_allocated_clientrespmsg(
      ::tutorial::ClientMessageResp* clientrespmsg);
  ::tutorial::ClientMessageResp* unsafe_arena_release_clientrespmsg();

  // optional .tutorial.DataMessageReq dataReqMsg = 101;
  bool has_datareqmsg() const;
  private:
  bool _internal_has_datareqmsg() const;
  public:
  void clear_datareqmsg();
  const ::tutorial::DataMessageReq& datareqmsg() const;
  ::tutorial::DataMessageReq* release_datareqmsg();
  ::tutorial::DataMessageReq* mutable_datareqmsg();
  void set_allocated_datareqmsg(::tutorial::DataMessageReq* datareqmsg);
  private:
  const ::tutorial::DataMessageReq& _internal_datareqmsg() const;
  ::tutorial::DataMessageReq* _internal_mutable_datareqmsg();
  public:
  void unsafe_arena_set_allocated_datareqmsg(
      ::tutorial::DataMessageReq* datareqmsg);
  ::tutorial::DataMessageReq* unsafe_arena_release_datareqmsg();

  // optional .tutorial.DataMessageResp dataRespMsg = 102;
  bool has_datarespmsg() const;
  private:
  bool _internal_has_datarespmsg() const;
  public:
  void clear_datarespmsg();
  const ::tutorial::DataMessageResp& datarespmsg() const;
  ::tutorial::DataMessageResp* release_datarespmsg();
  ::tutorial::DataMessageResp* mutable_datarespmsg();
  void set_allocated_datarespmsg(::tutorial::DataMessageResp* datarespmsg);
  private:
  const ::tutorial::DataMessageResp& _internal_datarespmsg() const;
  ::tutorial::DataMessageResp* _internal_mutable_datarespmsg();
  public:
  void unsafe_arena_set_allocated_datarespmsg(
      ::tutorial::DataMessageResp* datarespmsg);
  ::tutorial::DataMessageResp* unsafe_arena_release_datarespmsg();

  // required .tutorial.Message.Type messageType = 1;
  bool has_messagetype() const;
  private:
  bool _internal_has_messagetype() const;
  public:
  void clear_messagetype();
  ::tutorial::Message_Type messagetype() const;
  void set_messagetype(::tutorial::Message_Type value);
  private:
  ::tutorial::Message_Type _internal_messagetype() const;
  void _internal_set_messagetype(::tutorial::Message_Type value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::tutorial::ClientMessageReq* clientreqmsg_;
  ::tutorial::ClientMessageResp* clientrespmsg_;
  ::tutorial::DataMessageReq* datareqmsg_;
  ::tutorial::DataMessageResp* datarespmsg_;
  int messagetype_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class Statement PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Statement) */ {
 public:
  inline Statement() : Statement(nullptr) {}
  ~Statement() override;
  explicit constexpr Statement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Statement(const Statement& from);
  Statement(Statement&& from) noexcept
    : Statement() {
    *this = ::std::move(from);
  }

  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Statement& operator=(Statement&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Statement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
               &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Statement& a, Statement& b) {
    a.Swap(&b);
  }
  inline void Swap(Statement* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Statement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Statement* New() const final {
    return CreateMaybeMessage<Statement>(nullptr);
  }

  Statement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Statement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Statement& from);
  void MergeFrom(const Statement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Statement";
  }
  protected:
  explicit Statement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Statement_Type Type;
  static constexpr Type READ =
    Statement_Type_READ;
  static constexpr Type WRITE =
    Statement_Type_WRITE;
  static constexpr Type DELETE =
    Statement_Type_DELETE;
  static constexpr Type READ_FOR_UPDATE =
    Statement_Type_READ_FOR_UPDATE;
  static constexpr Type DUMMY =
    Statement_Type_DUMMY;
  static inline bool Type_IsValid(int value) {
    return Statement_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Statement_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Statement_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Statement_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Statement_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Statement_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Statement_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 3,
    kKeyFieldNumber = 2,
    kOpTypeFieldNumber = 1,
  };
  // optional bytes value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // required uint64 key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  ::PROTOBUF_NAMESPACE_ID::uint64 key() const;
  void set_key(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_key() const;
  void _internal_set_key(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .tutorial.Statement.Type opType = 1;
  bool has_optype() const;
  private:
  bool _internal_has_optype() const;
  public:
  void clear_optype();
  ::tutorial::Statement_Type optype() const;
  void set_optype(::tutorial::Statement_Type value);
  private:
  ::tutorial::Statement_Type _internal_optype() const;
  void _internal_set_optype(::tutorial::Statement_Type value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.Statement)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::uint64 key_;
  int optype_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientMessageReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.ClientMessageReq) */ {
 public:
  inline ClientMessageReq() : ClientMessageReq(nullptr) {}
  ~ClientMessageReq() override;
  explicit constexpr ClientMessageReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientMessageReq(const ClientMessageReq& from);
  ClientMessageReq(ClientMessageReq&& from) noexcept
    : ClientMessageReq() {
    *this = ::std::move(from);
  }

  inline ClientMessageReq& operator=(const ClientMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMessageReq& operator=(ClientMessageReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientMessageReq* internal_default_instance() {
    return reinterpret_cast<const ClientMessageReq*>(
               &_ClientMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientMessageReq& a, ClientMessageReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientMessageReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMessageReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientMessageReq* New() const final {
    return CreateMaybeMessage<ClientMessageReq>(nullptr);
  }

  ClientMessageReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientMessageReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientMessageReq& from);
  void MergeFrom(const ClientMessageReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessageReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.ClientMessageReq";
  }
  protected:
  explicit ClientMessageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperationsFieldNumber = 8,
    kClientHostFieldNumber = 6,
    kClientIdFieldNumber = 1,
    kRegisterFieldNumber = 2,
    kToStartFieldNumber = 3,
    kToCommitFieldNumber = 4,
    kToAbortFieldNumber = 5,
    kClientPortFieldNumber = 7,
    kToTerminateFieldNumber = 9,
  };
  // repeated .tutorial.Statement operations = 8;
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::tutorial::Statement* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Statement >*
      mutable_operations();
  private:
  const ::tutorial::Statement& _internal_operations(int index) const;
  ::tutorial::Statement* _internal_add_operations();
  public:
  const ::tutorial::Statement& operations(int index) const;
  ::tutorial::Statement* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Statement >&
      operations() const;

  // optional string clientHost = 6;
  bool has_clienthost() const;
  private:
  bool _internal_has_clienthost() const;
  public:
  void clear_clienthost();
  const std::string& clienthost() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clienthost(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clienthost();
  std::string* release_clienthost();
  void set_allocated_clienthost(std::string* clienthost);
  private:
  const std::string& _internal_clienthost() const;
  void _internal_set_clienthost(const std::string& value);
  std::string* _internal_mutable_clienthost();
  public:

  // required uint64 clientId = 1;
  bool has_clientid() const;
  private:
  bool _internal_has_clientid() const;
  public:
  void clear_clientid();
  ::PROTOBUF_NAMESPACE_ID::uint64 clientid() const;
  void set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_clientid() const;
  void _internal_set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool register = 2;
  bool has_register_() const;
  private:
  bool _internal_has_register_() const;
  public:
  void clear_register_();
  bool register_() const;
  void set_register_(bool value);
  private:
  bool _internal_register_() const;
  void _internal_set_register_(bool value);
  public:

  // optional bool toStart = 3;
  bool has_tostart() const;
  private:
  bool _internal_has_tostart() const;
  public:
  void clear_tostart();
  bool tostart() const;
  void set_tostart(bool value);
  private:
  bool _internal_tostart() const;
  void _internal_set_tostart(bool value);
  public:

  // optional bool toCommit = 4;
  bool has_tocommit() const;
  private:
  bool _internal_has_tocommit() const;
  public:
  void clear_tocommit();
  bool tocommit() const;
  void set_tocommit(bool value);
  private:
  bool _internal_tocommit() const;
  void _internal_set_tocommit(bool value);
  public:

  // optional bool toAbort = 5;
  bool has_toabort() const;
  private:
  bool _internal_has_toabort() const;
  public:
  void clear_toabort();
  bool toabort() const;
  void set_toabort(bool value);
  private:
  bool _internal_toabort() const;
  void _internal_set_toabort(bool value);
  public:

  // optional uint32 clientPort = 7;
  bool has_clientport() const;
  private:
  bool _internal_has_clientport() const;
  public:
  void clear_clientport();
  ::PROTOBUF_NAMESPACE_ID::uint32 clientport() const;
  void set_clientport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_clientport() const;
  void _internal_set_clientport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool toTerminate = 9;
  bool has_toterminate() const;
  private:
  bool _internal_has_toterminate() const;
  public:
  void clear_toterminate();
  bool toterminate() const;
  void set_toterminate(bool value);
  private:
  bool _internal_toterminate() const;
  void _internal_set_toterminate(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.ClientMessageReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Statement > operations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clienthost_;
  ::PROTOBUF_NAMESPACE_ID::uint64 clientid_;
  bool register__;
  bool tostart_;
  bool tocommit_;
  bool toabort_;
  ::PROTOBUF_NAMESPACE_ID::uint32 clientport_;
  bool toterminate_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class ClientMessageResp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.ClientMessageResp) */ {
 public:
  inline ClientMessageResp() : ClientMessageResp(nullptr) {}
  ~ClientMessageResp() override;
  explicit constexpr ClientMessageResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientMessageResp(const ClientMessageResp& from);
  ClientMessageResp(ClientMessageResp&& from) noexcept
    : ClientMessageResp() {
    *this = ::std::move(from);
  }

  inline ClientMessageResp& operator=(const ClientMessageResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientMessageResp& operator=(ClientMessageResp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientMessageResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientMessageResp* internal_default_instance() {
    return reinterpret_cast<const ClientMessageResp*>(
               &_ClientMessageResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClientMessageResp& a, ClientMessageResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientMessageResp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientMessageResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientMessageResp* New() const final {
    return CreateMaybeMessage<ClientMessageResp>(nullptr);
  }

  ClientMessageResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientMessageResp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientMessageResp& from);
  void MergeFrom(const ClientMessageResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessageResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.ClientMessageResp";
  }
  protected:
  explicit ClientMessageResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ClientMessageResp_RespType RespType;
  static constexpr RespType REGISTER =
    ClientMessageResp_RespType_REGISTER;
  static constexpr RespType OPERATION =
    ClientMessageResp_RespType_OPERATION;
  static constexpr RespType TERMINATE =
    ClientMessageResp_RespType_TERMINATE;
  static inline bool RespType_IsValid(int value) {
    return ClientMessageResp_RespType_IsValid(value);
  }
  static constexpr RespType RespType_MIN =
    ClientMessageResp_RespType_RespType_MIN;
  static constexpr RespType RespType_MAX =
    ClientMessageResp_RespType_RespType_MAX;
  static constexpr int RespType_ARRAYSIZE =
    ClientMessageResp_RespType_RespType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RespType_descriptor() {
    return ClientMessageResp_RespType_descriptor();
  }
  template<typename T>
  static inline const std::string& RespType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RespType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RespType_Name.");
    return ClientMessageResp_RespType_Name(enum_t_value);
  }
  static inline bool RespType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RespType* value) {
    return ClientMessageResp_RespType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kReadValuesFieldNumber = 4,
    kErrorMsgFieldNumber = 3,
    kIsErrorFieldNumber = 2,
    kRespTypeFieldNumber = 1,
  };
  // repeated bytes readValues = 4;
  int readvalues_size() const;
  private:
  int _internal_readvalues_size() const;
  public:
  void clear_readvalues();
  const std::string& readvalues(int index) const;
  std::string* mutable_readvalues(int index);
  void set_readvalues(int index, const std::string& value);
  void set_readvalues(int index, std::string&& value);
  void set_readvalues(int index, const char* value);
  void set_readvalues(int index, const void* value, size_t size);
  std::string* add_readvalues();
  void add_readvalues(const std::string& value);
  void add_readvalues(std::string&& value);
  void add_readvalues(const char* value);
  void add_readvalues(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& readvalues() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_readvalues();
  private:
  const std::string& _internal_readvalues(int index) const;
  std::string* _internal_add_readvalues();
  public:

  // optional string errorMsg = 3;
  bool has_errormsg() const;
  private:
  bool _internal_has_errormsg() const;
  public:
  void clear_errormsg();
  const std::string& errormsg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormsg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormsg();
  std::string* release_errormsg();
  void set_allocated_errormsg(std::string* errormsg);
  private:
  const std::string& _internal_errormsg() const;
  void _internal_set_errormsg(const std::string& value);
  std::string* _internal_mutable_errormsg();
  public:

  // required bool isError = 2;
  bool has_iserror() const;
  private:
  bool _internal_has_iserror() const;
  public:
  void clear_iserror();
  bool iserror() const;
  void set_iserror(bool value);
  private:
  bool _internal_iserror() const;
  void _internal_set_iserror(bool value);
  public:

  // required .tutorial.ClientMessageResp.RespType respType = 1;
  bool has_resptype() const;
  private:
  bool _internal_has_resptype() const;
  public:
  void clear_resptype();
  ::tutorial::ClientMessageResp_RespType resptype() const;
  void set_resptype(::tutorial::ClientMessageResp_RespType value);
  private:
  ::tutorial::ClientMessageResp_RespType _internal_resptype() const;
  void _internal_set_resptype(::tutorial::ClientMessageResp_RespType value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.ClientMessageResp)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> readvalues_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormsg_;
  bool iserror_;
  int resptype_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class DataMessageReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.DataMessageReq) */ {
 public:
  inline DataMessageReq() : DataMessageReq(nullptr) {}
  ~DataMessageReq() override;
  explicit constexpr DataMessageReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessageReq(const DataMessageReq& from);
  DataMessageReq(DataMessageReq&& from) noexcept
    : DataMessageReq() {
    *this = ::std::move(from);
  }

  inline DataMessageReq& operator=(const DataMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessageReq& operator=(DataMessageReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessageReq* internal_default_instance() {
    return reinterpret_cast<const DataMessageReq*>(
               &_DataMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DataMessageReq& a, DataMessageReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessageReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessageReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataMessageReq* New() const final {
    return CreateMaybeMessage<DataMessageReq>(nullptr);
  }

  DataMessageReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataMessageReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataMessageReq& from);
  void MergeFrom(const DataMessageReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMessageReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.DataMessageReq";
  }
  protected:
  explicit DataMessageReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
    kClientHostFieldNumber = 3,
    kClientIdFieldNumber = 2,
    kClientPortFieldNumber = 4,
  };
  // repeated .tutorial.Request requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::tutorial::Request* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Request >*
      mutable_requests();
  private:
  const ::tutorial::Request& _internal_requests(int index) const;
  ::tutorial::Request* _internal_add_requests();
  public:
  const ::tutorial::Request& requests(int index) const;
  ::tutorial::Request* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Request >&
      requests() const;

  // optional string clientHost = 3;
  bool has_clienthost() const;
  private:
  bool _internal_has_clienthost() const;
  public:
  void clear_clienthost();
  const std::string& clienthost() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clienthost(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clienthost();
  std::string* release_clienthost();
  void set_allocated_clienthost(std::string* clienthost);
  private:
  const std::string& _internal_clienthost() const;
  void _internal_set_clienthost(const std::string& value);
  std::string* _internal_mutable_clienthost();
  public:

  // optional uint64 clientId = 2;
  bool has_clientid() const;
  private:
  bool _internal_has_clientid() const;
  public:
  void clear_clientid();
  ::PROTOBUF_NAMESPACE_ID::uint64 clientid() const;
  void set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_clientid() const;
  void _internal_set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 clientPort = 4;
  bool has_clientport() const;
  private:
  bool _internal_has_clientport() const;
  public:
  void clear_clientport();
  ::PROTOBUF_NAMESPACE_ID::uint32 clientport() const;
  void set_clientport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_clientport() const;
  void _internal_set_clientport(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.DataMessageReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Request > requests_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clienthost_;
  ::PROTOBUF_NAMESPACE_ID::uint64 clientid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 clientport_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class Request PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit constexpr Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Request_ReqType ReqType;
  static constexpr ReqType READ =
    Request_ReqType_READ;
  static constexpr ReqType WRITE =
    Request_ReqType_WRITE;
  static constexpr ReqType DELETE =
    Request_ReqType_DELETE;
  static inline bool ReqType_IsValid(int value) {
    return Request_ReqType_IsValid(value);
  }
  static constexpr ReqType ReqType_MIN =
    Request_ReqType_ReqType_MIN;
  static constexpr ReqType ReqType_MAX =
    Request_ReqType_ReqType_MAX;
  static constexpr int ReqType_ARRAYSIZE =
    Request_ReqType_ReqType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ReqType_descriptor() {
    return Request_ReqType_descriptor();
  }
  template<typename T>
  static inline const std::string& ReqType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReqType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReqType_Name.");
    return Request_ReqType_Name(enum_t_value);
  }
  static inline bool ReqType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ReqType* value) {
    return Request_ReqType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 4,
    kOpIdFieldNumber = 2,
    kKeyFieldNumber = 3,
    kReqTypeFieldNumber = 1,
  };
  // optional bytes value = 4;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // required uint64 opId = 2;
  bool has_opid() const;
  private:
  bool _internal_has_opid() const;
  public:
  void clear_opid();
  ::PROTOBUF_NAMESPACE_ID::uint64 opid() const;
  void set_opid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_opid() const;
  void _internal_set_opid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 key = 3;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  ::PROTOBUF_NAMESPACE_ID::uint64 key() const;
  void set_key(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_key() const;
  void _internal_set_key(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .tutorial.Request.ReqType reqType = 1;
  bool has_reqtype() const;
  private:
  bool _internal_has_reqtype() const;
  public:
  void clear_reqtype();
  ::tutorial::Request_ReqType reqtype() const;
  void set_reqtype(::tutorial::Request_ReqType value);
  private:
  ::tutorial::Request_ReqType _internal_reqtype() const;
  void _internal_set_reqtype(::tutorial::Request_ReqType value);
  public:

  // @@protoc_insertion_point(class_scope:tutorial.Request)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::uint64 opid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 key_;
  int reqtype_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class DataMessageResp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tutorial.DataMessageResp) */ {
 public:
  inline DataMessageResp() : DataMessageResp(nullptr) {}
  ~DataMessageResp() override;
  explicit constexpr DataMessageResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataMessageResp(const DataMessageResp& from);
  DataMessageResp(DataMessageResp&& from) noexcept
    : DataMessageResp() {
    *this = ::std::move(from);
  }

  inline DataMessageResp& operator=(const DataMessageResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataMessageResp& operator=(DataMessageResp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataMessageResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataMessageResp* internal_default_instance() {
    return reinterpret_cast<const DataMessageResp*>(
               &_DataMessageResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DataMessageResp& a, DataMessageResp& b) {
    a.Swap(&b);
  }
  inline void Swap(DataMessageResp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataMessageResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataMessageResp* New() const final {
    return CreateMaybeMessage<DataMessageResp>(nullptr);
  }

  DataMessageResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataMessageResp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataMessageResp& from);
  void MergeFrom(const DataMessageResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataMessageResp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tutorial.DataMessageResp";
  }
  protected:
  explicit DataMessageResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestsFieldNumber = 1,
  };
  // repeated .tutorial.Request requests = 1;
  int requests_size() const;
  private:
  int _internal_requests_size() const;
  public:
  void clear_requests();
  ::tutorial::Request* mutable_requests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Request >*
      mutable_requests();
  private:
  const ::tutorial::Request& _internal_requests(int index) const;
  ::tutorial::Request* _internal_add_requests();
  public:
  const ::tutorial::Request& requests(int index) const;
  ::tutorial::Request* add_requests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Request >&
      requests() const;

  // @@protoc_insertion_point(class_scope:tutorial.DataMessageResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Request > requests_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Message

// required .tutorial.Message.Type messageType = 1;
inline bool Message::_internal_has_messagetype() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Message::has_messagetype() const {
  return _internal_has_messagetype();
}
inline void Message::clear_messagetype() {
  messagetype_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::tutorial::Message_Type Message::_internal_messagetype() const {
  return static_cast< ::tutorial::Message_Type >(messagetype_);
}
inline ::tutorial::Message_Type Message::messagetype() const {
  // @@protoc_insertion_point(field_get:tutorial.Message.messageType)
  return _internal_messagetype();
}
inline void Message::_internal_set_messagetype(::tutorial::Message_Type value) {
  assert(::tutorial::Message_Type_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  messagetype_ = value;
}
inline void Message::set_messagetype(::tutorial::Message_Type value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:tutorial.Message.messageType)
}

// optional .tutorial.ClientMessageReq clientReqMsg = 3;
inline bool Message::_internal_has_clientreqmsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || clientreqmsg_ != nullptr);
  return value;
}
inline bool Message::has_clientreqmsg() const {
  return _internal_has_clientreqmsg();
}
inline void Message::clear_clientreqmsg() {
  if (clientreqmsg_ != nullptr) clientreqmsg_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::tutorial::ClientMessageReq& Message::_internal_clientreqmsg() const {
  const ::tutorial::ClientMessageReq* p = clientreqmsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::tutorial::ClientMessageReq&>(
      ::tutorial::_ClientMessageReq_default_instance_);
}
inline const ::tutorial::ClientMessageReq& Message::clientreqmsg() const {
  // @@protoc_insertion_point(field_get:tutorial.Message.clientReqMsg)
  return _internal_clientreqmsg();
}
inline void Message::unsafe_arena_set_allocated_clientreqmsg(
    ::tutorial::ClientMessageReq* clientreqmsg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clientreqmsg_);
  }
  clientreqmsg_ = clientreqmsg;
  if (clientreqmsg) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.Message.clientReqMsg)
}
inline ::tutorial::ClientMessageReq* Message::release_clientreqmsg() {
  _has_bits_[0] &= ~0x00000001u;
  ::tutorial::ClientMessageReq* temp = clientreqmsg_;
  clientreqmsg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::tutorial::ClientMessageReq* Message::unsafe_arena_release_clientreqmsg() {
  // @@protoc_insertion_point(field_release:tutorial.Message.clientReqMsg)
  _has_bits_[0] &= ~0x00000001u;
  ::tutorial::ClientMessageReq* temp = clientreqmsg_;
  clientreqmsg_ = nullptr;
  return temp;
}
inline ::tutorial::ClientMessageReq* Message::_internal_mutable_clientreqmsg() {
  _has_bits_[0] |= 0x00000001u;
  if (clientreqmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::tutorial::ClientMessageReq>(GetArena());
    clientreqmsg_ = p;
  }
  return clientreqmsg_;
}
inline ::tutorial::ClientMessageReq* Message::mutable_clientreqmsg() {
  // @@protoc_insertion_point(field_mutable:tutorial.Message.clientReqMsg)
  return _internal_mutable_clientreqmsg();
}
inline void Message::set_allocated_clientreqmsg(::tutorial::ClientMessageReq* clientreqmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete clientreqmsg_;
  }
  if (clientreqmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(clientreqmsg);
    if (message_arena != submessage_arena) {
      clientreqmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clientreqmsg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  clientreqmsg_ = clientreqmsg;
  // @@protoc_insertion_point(field_set_allocated:tutorial.Message.clientReqMsg)
}

// optional .tutorial.ClientMessageResp clientRespMsg = 4;
inline bool Message::_internal_has_clientrespmsg() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || clientrespmsg_ != nullptr);
  return value;
}
inline bool Message::has_clientrespmsg() const {
  return _internal_has_clientrespmsg();
}
inline void Message::clear_clientrespmsg() {
  if (clientrespmsg_ != nullptr) clientrespmsg_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::tutorial::ClientMessageResp& Message::_internal_clientrespmsg() const {
  const ::tutorial::ClientMessageResp* p = clientrespmsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::tutorial::ClientMessageResp&>(
      ::tutorial::_ClientMessageResp_default_instance_);
}
inline const ::tutorial::ClientMessageResp& Message::clientrespmsg() const {
  // @@protoc_insertion_point(field_get:tutorial.Message.clientRespMsg)
  return _internal_clientrespmsg();
}
inline void Message::unsafe_arena_set_allocated_clientrespmsg(
    ::tutorial::ClientMessageResp* clientrespmsg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clientrespmsg_);
  }
  clientrespmsg_ = clientrespmsg;
  if (clientrespmsg) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.Message.clientRespMsg)
}
inline ::tutorial::ClientMessageResp* Message::release_clientrespmsg() {
  _has_bits_[0] &= ~0x00000002u;
  ::tutorial::ClientMessageResp* temp = clientrespmsg_;
  clientrespmsg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::tutorial::ClientMessageResp* Message::unsafe_arena_release_clientrespmsg() {
  // @@protoc_insertion_point(field_release:tutorial.Message.clientRespMsg)
  _has_bits_[0] &= ~0x00000002u;
  ::tutorial::ClientMessageResp* temp = clientrespmsg_;
  clientrespmsg_ = nullptr;
  return temp;
}
inline ::tutorial::ClientMessageResp* Message::_internal_mutable_clientrespmsg() {
  _has_bits_[0] |= 0x00000002u;
  if (clientrespmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::tutorial::ClientMessageResp>(GetArena());
    clientrespmsg_ = p;
  }
  return clientrespmsg_;
}
inline ::tutorial::ClientMessageResp* Message::mutable_clientrespmsg() {
  // @@protoc_insertion_point(field_mutable:tutorial.Message.clientRespMsg)
  return _internal_mutable_clientrespmsg();
}
inline void Message::set_allocated_clientrespmsg(::tutorial::ClientMessageResp* clientrespmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete clientrespmsg_;
  }
  if (clientrespmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(clientrespmsg);
    if (message_arena != submessage_arena) {
      clientrespmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clientrespmsg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  clientrespmsg_ = clientrespmsg;
  // @@protoc_insertion_point(field_set_allocated:tutorial.Message.clientRespMsg)
}

// optional .tutorial.DataMessageReq dataReqMsg = 101;
inline bool Message::_internal_has_datareqmsg() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || datareqmsg_ != nullptr);
  return value;
}
inline bool Message::has_datareqmsg() const {
  return _internal_has_datareqmsg();
}
inline void Message::clear_datareqmsg() {
  if (datareqmsg_ != nullptr) datareqmsg_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::tutorial::DataMessageReq& Message::_internal_datareqmsg() const {
  const ::tutorial::DataMessageReq* p = datareqmsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::tutorial::DataMessageReq&>(
      ::tutorial::_DataMessageReq_default_instance_);
}
inline const ::tutorial::DataMessageReq& Message::datareqmsg() const {
  // @@protoc_insertion_point(field_get:tutorial.Message.dataReqMsg)
  return _internal_datareqmsg();
}
inline void Message::unsafe_arena_set_allocated_datareqmsg(
    ::tutorial::DataMessageReq* datareqmsg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(datareqmsg_);
  }
  datareqmsg_ = datareqmsg;
  if (datareqmsg) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.Message.dataReqMsg)
}
inline ::tutorial::DataMessageReq* Message::release_datareqmsg() {
  _has_bits_[0] &= ~0x00000004u;
  ::tutorial::DataMessageReq* temp = datareqmsg_;
  datareqmsg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::tutorial::DataMessageReq* Message::unsafe_arena_release_datareqmsg() {
  // @@protoc_insertion_point(field_release:tutorial.Message.dataReqMsg)
  _has_bits_[0] &= ~0x00000004u;
  ::tutorial::DataMessageReq* temp = datareqmsg_;
  datareqmsg_ = nullptr;
  return temp;
}
inline ::tutorial::DataMessageReq* Message::_internal_mutable_datareqmsg() {
  _has_bits_[0] |= 0x00000004u;
  if (datareqmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::tutorial::DataMessageReq>(GetArena());
    datareqmsg_ = p;
  }
  return datareqmsg_;
}
inline ::tutorial::DataMessageReq* Message::mutable_datareqmsg() {
  // @@protoc_insertion_point(field_mutable:tutorial.Message.dataReqMsg)
  return _internal_mutable_datareqmsg();
}
inline void Message::set_allocated_datareqmsg(::tutorial::DataMessageReq* datareqmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete datareqmsg_;
  }
  if (datareqmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(datareqmsg);
    if (message_arena != submessage_arena) {
      datareqmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datareqmsg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  datareqmsg_ = datareqmsg;
  // @@protoc_insertion_point(field_set_allocated:tutorial.Message.dataReqMsg)
}

// optional .tutorial.DataMessageResp dataRespMsg = 102;
inline bool Message::_internal_has_datarespmsg() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || datarespmsg_ != nullptr);
  return value;
}
inline bool Message::has_datarespmsg() const {
  return _internal_has_datarespmsg();
}
inline void Message::clear_datarespmsg() {
  if (datarespmsg_ != nullptr) datarespmsg_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::tutorial::DataMessageResp& Message::_internal_datarespmsg() const {
  const ::tutorial::DataMessageResp* p = datarespmsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::tutorial::DataMessageResp&>(
      ::tutorial::_DataMessageResp_default_instance_);
}
inline const ::tutorial::DataMessageResp& Message::datarespmsg() const {
  // @@protoc_insertion_point(field_get:tutorial.Message.dataRespMsg)
  return _internal_datarespmsg();
}
inline void Message::unsafe_arena_set_allocated_datarespmsg(
    ::tutorial::DataMessageResp* datarespmsg) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(datarespmsg_);
  }
  datarespmsg_ = datarespmsg;
  if (datarespmsg) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tutorial.Message.dataRespMsg)
}
inline ::tutorial::DataMessageResp* Message::release_datarespmsg() {
  _has_bits_[0] &= ~0x00000008u;
  ::tutorial::DataMessageResp* temp = datarespmsg_;
  datarespmsg_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::tutorial::DataMessageResp* Message::unsafe_arena_release_datarespmsg() {
  // @@protoc_insertion_point(field_release:tutorial.Message.dataRespMsg)
  _has_bits_[0] &= ~0x00000008u;
  ::tutorial::DataMessageResp* temp = datarespmsg_;
  datarespmsg_ = nullptr;
  return temp;
}
inline ::tutorial::DataMessageResp* Message::_internal_mutable_datarespmsg() {
  _has_bits_[0] |= 0x00000008u;
  if (datarespmsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::tutorial::DataMessageResp>(GetArena());
    datarespmsg_ = p;
  }
  return datarespmsg_;
}
inline ::tutorial::DataMessageResp* Message::mutable_datarespmsg() {
  // @@protoc_insertion_point(field_mutable:tutorial.Message.dataRespMsg)
  return _internal_mutable_datarespmsg();
}
inline void Message::set_allocated_datarespmsg(::tutorial::DataMessageResp* datarespmsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete datarespmsg_;
  }
  if (datarespmsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(datarespmsg);
    if (message_arena != submessage_arena) {
      datarespmsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datarespmsg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  datarespmsg_ = datarespmsg;
  // @@protoc_insertion_point(field_set_allocated:tutorial.Message.dataRespMsg)
}

// -------------------------------------------------------------------

// Statement

// required .tutorial.Statement.Type opType = 1;
inline bool Statement::_internal_has_optype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Statement::has_optype() const {
  return _internal_has_optype();
}
inline void Statement::clear_optype() {
  optype_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::tutorial::Statement_Type Statement::_internal_optype() const {
  return static_cast< ::tutorial::Statement_Type >(optype_);
}
inline ::tutorial::Statement_Type Statement::optype() const {
  // @@protoc_insertion_point(field_get:tutorial.Statement.opType)
  return _internal_optype();
}
inline void Statement::_internal_set_optype(::tutorial::Statement_Type value) {
  assert(::tutorial::Statement_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  optype_ = value;
}
inline void Statement::set_optype(::tutorial::Statement_Type value) {
  _internal_set_optype(value);
  // @@protoc_insertion_point(field_set:tutorial.Statement.opType)
}

// required uint64 key = 2;
inline bool Statement::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Statement::has_key() const {
  return _internal_has_key();
}
inline void Statement::clear_key() {
  key_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Statement::_internal_key() const {
  return key_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Statement::key() const {
  // @@protoc_insertion_point(field_get:tutorial.Statement.key)
  return _internal_key();
}
inline void Statement::_internal_set_key(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  key_ = value;
}
inline void Statement::set_key(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:tutorial.Statement.key)
}

// optional bytes value = 3;
inline bool Statement::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Statement::has_value() const {
  return _internal_has_value();
}
inline void Statement::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Statement::value() const {
  // @@protoc_insertion_point(field_get:tutorial.Statement.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Statement::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:tutorial.Statement.value)
}
inline std::string* Statement::mutable_value() {
  // @@protoc_insertion_point(field_mutable:tutorial.Statement.value)
  return _internal_mutable_value();
}
inline const std::string& Statement::_internal_value() const {
  return value_.Get();
}
inline void Statement::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Statement::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Statement::release_value() {
  // @@protoc_insertion_point(field_release:tutorial.Statement.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Statement::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tutorial.Statement.value)
}

// -------------------------------------------------------------------

// ClientMessageReq

// required uint64 clientId = 1;
inline bool ClientMessageReq::_internal_has_clientid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientMessageReq::has_clientid() const {
  return _internal_has_clientid();
}
inline void ClientMessageReq::clear_clientid() {
  clientid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientMessageReq::_internal_clientid() const {
  return clientid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ClientMessageReq::clientid() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageReq.clientId)
  return _internal_clientid();
}
inline void ClientMessageReq::_internal_set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  clientid_ = value;
}
inline void ClientMessageReq::set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageReq.clientId)
}

// optional bool register = 2;
inline bool ClientMessageReq::_internal_has_register_() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientMessageReq::has_register_() const {
  return _internal_has_register_();
}
inline void ClientMessageReq::clear_register_() {
  register__ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ClientMessageReq::_internal_register_() const {
  return register__;
}
inline bool ClientMessageReq::register_() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageReq.register)
  return _internal_register_();
}
inline void ClientMessageReq::_internal_set_register_(bool value) {
  _has_bits_[0] |= 0x00000004u;
  register__ = value;
}
inline void ClientMessageReq::set_register_(bool value) {
  _internal_set_register_(value);
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageReq.register)
}

// optional bool toStart = 3;
inline bool ClientMessageReq::_internal_has_tostart() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClientMessageReq::has_tostart() const {
  return _internal_has_tostart();
}
inline void ClientMessageReq::clear_tostart() {
  tostart_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ClientMessageReq::_internal_tostart() const {
  return tostart_;
}
inline bool ClientMessageReq::tostart() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageReq.toStart)
  return _internal_tostart();
}
inline void ClientMessageReq::_internal_set_tostart(bool value) {
  _has_bits_[0] |= 0x00000008u;
  tostart_ = value;
}
inline void ClientMessageReq::set_tostart(bool value) {
  _internal_set_tostart(value);
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageReq.toStart)
}

// optional bool toCommit = 4;
inline bool ClientMessageReq::_internal_has_tocommit() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ClientMessageReq::has_tocommit() const {
  return _internal_has_tocommit();
}
inline void ClientMessageReq::clear_tocommit() {
  tocommit_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ClientMessageReq::_internal_tocommit() const {
  return tocommit_;
}
inline bool ClientMessageReq::tocommit() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageReq.toCommit)
  return _internal_tocommit();
}
inline void ClientMessageReq::_internal_set_tocommit(bool value) {
  _has_bits_[0] |= 0x00000010u;
  tocommit_ = value;
}
inline void ClientMessageReq::set_tocommit(bool value) {
  _internal_set_tocommit(value);
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageReq.toCommit)
}

// optional bool toAbort = 5;
inline bool ClientMessageReq::_internal_has_toabort() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ClientMessageReq::has_toabort() const {
  return _internal_has_toabort();
}
inline void ClientMessageReq::clear_toabort() {
  toabort_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ClientMessageReq::_internal_toabort() const {
  return toabort_;
}
inline bool ClientMessageReq::toabort() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageReq.toAbort)
  return _internal_toabort();
}
inline void ClientMessageReq::_internal_set_toabort(bool value) {
  _has_bits_[0] |= 0x00000020u;
  toabort_ = value;
}
inline void ClientMessageReq::set_toabort(bool value) {
  _internal_set_toabort(value);
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageReq.toAbort)
}

// optional string clientHost = 6;
inline bool ClientMessageReq::_internal_has_clienthost() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientMessageReq::has_clienthost() const {
  return _internal_has_clienthost();
}
inline void ClientMessageReq::clear_clienthost() {
  clienthost_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientMessageReq::clienthost() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageReq.clientHost)
  return _internal_clienthost();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void ClientMessageReq::set_clienthost(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 clienthost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageReq.clientHost)
}
inline std::string* ClientMessageReq::mutable_clienthost() {
  // @@protoc_insertion_point(field_mutable:tutorial.ClientMessageReq.clientHost)
  return _internal_mutable_clienthost();
}
inline const std::string& ClientMessageReq::_internal_clienthost() const {
  return clienthost_.Get();
}
inline void ClientMessageReq::_internal_set_clienthost(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  clienthost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* ClientMessageReq::_internal_mutable_clienthost() {
  _has_bits_[0] |= 0x00000001u;
  return clienthost_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ClientMessageReq::release_clienthost() {
  // @@protoc_insertion_point(field_release:tutorial.ClientMessageReq.clientHost)
  if (!_internal_has_clienthost()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return clienthost_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientMessageReq::set_allocated_clienthost(std::string* clienthost) {
  if (clienthost != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  clienthost_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clienthost,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tutorial.ClientMessageReq.clientHost)
}

// optional uint32 clientPort = 7;
inline bool ClientMessageReq::_internal_has_clientport() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ClientMessageReq::has_clientport() const {
  return _internal_has_clientport();
}
inline void ClientMessageReq::clear_clientport() {
  clientport_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientMessageReq::_internal_clientport() const {
  return clientport_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ClientMessageReq::clientport() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageReq.clientPort)
  return _internal_clientport();
}
inline void ClientMessageReq::_internal_set_clientport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  clientport_ = value;
}
inline void ClientMessageReq::set_clientport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_clientport(value);
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageReq.clientPort)
}

// repeated .tutorial.Statement operations = 8;
inline int ClientMessageReq::_internal_operations_size() const {
  return operations_.size();
}
inline int ClientMessageReq::operations_size() const {
  return _internal_operations_size();
}
inline void ClientMessageReq::clear_operations() {
  operations_.Clear();
}
inline ::tutorial::Statement* ClientMessageReq::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.ClientMessageReq.operations)
  return operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Statement >*
ClientMessageReq::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.ClientMessageReq.operations)
  return &operations_;
}
inline const ::tutorial::Statement& ClientMessageReq::_internal_operations(int index) const {
  return operations_.Get(index);
}
inline const ::tutorial::Statement& ClientMessageReq::operations(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageReq.operations)
  return _internal_operations(index);
}
inline ::tutorial::Statement* ClientMessageReq::_internal_add_operations() {
  return operations_.Add();
}
inline ::tutorial::Statement* ClientMessageReq::add_operations() {
  // @@protoc_insertion_point(field_add:tutorial.ClientMessageReq.operations)
  return _internal_add_operations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Statement >&
ClientMessageReq::operations() const {
  // @@protoc_insertion_point(field_list:tutorial.ClientMessageReq.operations)
  return operations_;
}

// optional bool toTerminate = 9;
inline bool ClientMessageReq::_internal_has_toterminate() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ClientMessageReq::has_toterminate() const {
  return _internal_has_toterminate();
}
inline void ClientMessageReq::clear_toterminate() {
  toterminate_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ClientMessageReq::_internal_toterminate() const {
  return toterminate_;
}
inline bool ClientMessageReq::toterminate() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageReq.toTerminate)
  return _internal_toterminate();
}
inline void ClientMessageReq::_internal_set_toterminate(bool value) {
  _has_bits_[0] |= 0x00000080u;
  toterminate_ = value;
}
inline void ClientMessageReq::set_toterminate(bool value) {
  _internal_set_toterminate(value);
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageReq.toTerminate)
}

// -------------------------------------------------------------------

// ClientMessageResp

// required .tutorial.ClientMessageResp.RespType respType = 1;
inline bool ClientMessageResp::_internal_has_resptype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientMessageResp::has_resptype() const {
  return _internal_has_resptype();
}
inline void ClientMessageResp::clear_resptype() {
  resptype_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::tutorial::ClientMessageResp_RespType ClientMessageResp::_internal_resptype() const {
  return static_cast< ::tutorial::ClientMessageResp_RespType >(resptype_);
}
inline ::tutorial::ClientMessageResp_RespType ClientMessageResp::resptype() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageResp.respType)
  return _internal_resptype();
}
inline void ClientMessageResp::_internal_set_resptype(::tutorial::ClientMessageResp_RespType value) {
  assert(::tutorial::ClientMessageResp_RespType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  resptype_ = value;
}
inline void ClientMessageResp::set_resptype(::tutorial::ClientMessageResp_RespType value) {
  _internal_set_resptype(value);
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageResp.respType)
}

// required bool isError = 2;
inline bool ClientMessageResp::_internal_has_iserror() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientMessageResp::has_iserror() const {
  return _internal_has_iserror();
}
inline void ClientMessageResp::clear_iserror() {
  iserror_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ClientMessageResp::_internal_iserror() const {
  return iserror_;
}
inline bool ClientMessageResp::iserror() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageResp.isError)
  return _internal_iserror();
}
inline void ClientMessageResp::_internal_set_iserror(bool value) {
  _has_bits_[0] |= 0x00000002u;
  iserror_ = value;
}
inline void ClientMessageResp::set_iserror(bool value) {
  _internal_set_iserror(value);
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageResp.isError)
}

// optional string errorMsg = 3;
inline bool ClientMessageResp::_internal_has_errormsg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientMessageResp::has_errormsg() const {
  return _internal_has_errormsg();
}
inline void ClientMessageResp::clear_errormsg() {
  errormsg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientMessageResp::errormsg() const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageResp.errorMsg)
  return _internal_errormsg();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void ClientMessageResp::set_errormsg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 errormsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageResp.errorMsg)
}
inline std::string* ClientMessageResp::mutable_errormsg() {
  // @@protoc_insertion_point(field_mutable:tutorial.ClientMessageResp.errorMsg)
  return _internal_mutable_errormsg();
}
inline const std::string& ClientMessageResp::_internal_errormsg() const {
  return errormsg_.Get();
}
inline void ClientMessageResp::_internal_set_errormsg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errormsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* ClientMessageResp::_internal_mutable_errormsg() {
  _has_bits_[0] |= 0x00000001u;
  return errormsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ClientMessageResp::release_errormsg() {
  // @@protoc_insertion_point(field_release:tutorial.ClientMessageResp.errorMsg)
  if (!_internal_has_errormsg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errormsg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClientMessageResp::set_allocated_errormsg(std::string* errormsg) {
  if (errormsg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errormsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormsg,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tutorial.ClientMessageResp.errorMsg)
}

// repeated bytes readValues = 4;
inline int ClientMessageResp::_internal_readvalues_size() const {
  return readvalues_.size();
}
inline int ClientMessageResp::readvalues_size() const {
  return _internal_readvalues_size();
}
inline void ClientMessageResp::clear_readvalues() {
  readvalues_.Clear();
}
inline std::string* ClientMessageResp::add_readvalues() {
  // @@protoc_insertion_point(field_add_mutable:tutorial.ClientMessageResp.readValues)
  return _internal_add_readvalues();
}
inline const std::string& ClientMessageResp::_internal_readvalues(int index) const {
  return readvalues_.Get(index);
}
inline const std::string& ClientMessageResp::readvalues(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.ClientMessageResp.readValues)
  return _internal_readvalues(index);
}
inline std::string* ClientMessageResp::mutable_readvalues(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.ClientMessageResp.readValues)
  return readvalues_.Mutable(index);
}
inline void ClientMessageResp::set_readvalues(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageResp.readValues)
  readvalues_.Mutable(index)->assign(value);
}
inline void ClientMessageResp::set_readvalues(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:tutorial.ClientMessageResp.readValues)
  readvalues_.Mutable(index)->assign(std::move(value));
}
inline void ClientMessageResp::set_readvalues(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  readvalues_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tutorial.ClientMessageResp.readValues)
}
inline void ClientMessageResp::set_readvalues(int index, const void* value, size_t size) {
  readvalues_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tutorial.ClientMessageResp.readValues)
}
inline std::string* ClientMessageResp::_internal_add_readvalues() {
  return readvalues_.Add();
}
inline void ClientMessageResp::add_readvalues(const std::string& value) {
  readvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tutorial.ClientMessageResp.readValues)
}
inline void ClientMessageResp::add_readvalues(std::string&& value) {
  readvalues_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tutorial.ClientMessageResp.readValues)
}
inline void ClientMessageResp::add_readvalues(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  readvalues_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tutorial.ClientMessageResp.readValues)
}
inline void ClientMessageResp::add_readvalues(const void* value, size_t size) {
  readvalues_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tutorial.ClientMessageResp.readValues)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ClientMessageResp::readvalues() const {
  // @@protoc_insertion_point(field_list:tutorial.ClientMessageResp.readValues)
  return readvalues_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ClientMessageResp::mutable_readvalues() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.ClientMessageResp.readValues)
  return &readvalues_;
}

// -------------------------------------------------------------------

// DataMessageReq

// repeated .tutorial.Request requests = 1;
inline int DataMessageReq::_internal_requests_size() const {
  return requests_.size();
}
inline int DataMessageReq::requests_size() const {
  return _internal_requests_size();
}
inline void DataMessageReq::clear_requests() {
  requests_.Clear();
}
inline ::tutorial::Request* DataMessageReq::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.DataMessageReq.requests)
  return requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Request >*
DataMessageReq::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.DataMessageReq.requests)
  return &requests_;
}
inline const ::tutorial::Request& DataMessageReq::_internal_requests(int index) const {
  return requests_.Get(index);
}
inline const ::tutorial::Request& DataMessageReq::requests(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.DataMessageReq.requests)
  return _internal_requests(index);
}
inline ::tutorial::Request* DataMessageReq::_internal_add_requests() {
  return requests_.Add();
}
inline ::tutorial::Request* DataMessageReq::add_requests() {
  // @@protoc_insertion_point(field_add:tutorial.DataMessageReq.requests)
  return _internal_add_requests();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Request >&
DataMessageReq::requests() const {
  // @@protoc_insertion_point(field_list:tutorial.DataMessageReq.requests)
  return requests_;
}

// optional uint64 clientId = 2;
inline bool DataMessageReq::_internal_has_clientid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataMessageReq::has_clientid() const {
  return _internal_has_clientid();
}
inline void DataMessageReq::clear_clientid() {
  clientid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DataMessageReq::_internal_clientid() const {
  return clientid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DataMessageReq::clientid() const {
  // @@protoc_insertion_point(field_get:tutorial.DataMessageReq.clientId)
  return _internal_clientid();
}
inline void DataMessageReq::_internal_set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  clientid_ = value;
}
inline void DataMessageReq::set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:tutorial.DataMessageReq.clientId)
}

// optional string clientHost = 3;
inline bool DataMessageReq::_internal_has_clienthost() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataMessageReq::has_clienthost() const {
  return _internal_has_clienthost();
}
inline void DataMessageReq::clear_clienthost() {
  clienthost_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessageReq::clienthost() const {
  // @@protoc_insertion_point(field_get:tutorial.DataMessageReq.clientHost)
  return _internal_clienthost();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void DataMessageReq::set_clienthost(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 clienthost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:tutorial.DataMessageReq.clientHost)
}
inline std::string* DataMessageReq::mutable_clienthost() {
  // @@protoc_insertion_point(field_mutable:tutorial.DataMessageReq.clientHost)
  return _internal_mutable_clienthost();
}
inline const std::string& DataMessageReq::_internal_clienthost() const {
  return clienthost_.Get();
}
inline void DataMessageReq::_internal_set_clienthost(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  clienthost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* DataMessageReq::_internal_mutable_clienthost() {
  _has_bits_[0] |= 0x00000001u;
  return clienthost_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DataMessageReq::release_clienthost() {
  // @@protoc_insertion_point(field_release:tutorial.DataMessageReq.clientHost)
  if (!_internal_has_clienthost()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return clienthost_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DataMessageReq::set_allocated_clienthost(std::string* clienthost) {
  if (clienthost != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  clienthost_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clienthost,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tutorial.DataMessageReq.clientHost)
}

// optional uint32 clientPort = 4;
inline bool DataMessageReq::_internal_has_clientport() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataMessageReq::has_clientport() const {
  return _internal_has_clientport();
}
inline void DataMessageReq::clear_clientport() {
  clientport_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataMessageReq::_internal_clientport() const {
  return clientport_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataMessageReq::clientport() const {
  // @@protoc_insertion_point(field_get:tutorial.DataMessageReq.clientPort)
  return _internal_clientport();
}
inline void DataMessageReq::_internal_set_clientport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  clientport_ = value;
}
inline void DataMessageReq::set_clientport(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_clientport(value);
  // @@protoc_insertion_point(field_set:tutorial.DataMessageReq.clientPort)
}

// -------------------------------------------------------------------

// Request

// required .tutorial.Request.ReqType reqType = 1;
inline bool Request::_internal_has_reqtype() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Request::has_reqtype() const {
  return _internal_has_reqtype();
}
inline void Request::clear_reqtype() {
  reqtype_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::tutorial::Request_ReqType Request::_internal_reqtype() const {
  return static_cast< ::tutorial::Request_ReqType >(reqtype_);
}
inline ::tutorial::Request_ReqType Request::reqtype() const {
  // @@protoc_insertion_point(field_get:tutorial.Request.reqType)
  return _internal_reqtype();
}
inline void Request::_internal_set_reqtype(::tutorial::Request_ReqType value) {
  assert(::tutorial::Request_ReqType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  reqtype_ = value;
}
inline void Request::set_reqtype(::tutorial::Request_ReqType value) {
  _internal_set_reqtype(value);
  // @@protoc_insertion_point(field_set:tutorial.Request.reqType)
}

// required uint64 opId = 2;
inline bool Request::_internal_has_opid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Request::has_opid() const {
  return _internal_has_opid();
}
inline void Request::clear_opid() {
  opid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::_internal_opid() const {
  return opid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::opid() const {
  // @@protoc_insertion_point(field_get:tutorial.Request.opId)
  return _internal_opid();
}
inline void Request::_internal_set_opid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  opid_ = value;
}
inline void Request::set_opid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_opid(value);
  // @@protoc_insertion_point(field_set:tutorial.Request.opId)
}

// optional uint64 key = 3;
inline bool Request::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Request::has_key() const {
  return _internal_has_key();
}
inline void Request::clear_key() {
  key_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::_internal_key() const {
  return key_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Request::key() const {
  // @@protoc_insertion_point(field_get:tutorial.Request.key)
  return _internal_key();
}
inline void Request::_internal_set_key(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  key_ = value;
}
inline void Request::set_key(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:tutorial.Request.key)
}

// optional bytes value = 4;
inline bool Request::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Request::has_value() const {
  return _internal_has_value();
}
inline void Request::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Request::value() const {
  // @@protoc_insertion_point(field_get:tutorial.Request.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Request::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:tutorial.Request.value)
}
inline std::string* Request::mutable_value() {
  // @@protoc_insertion_point(field_mutable:tutorial.Request.value)
  return _internal_mutable_value();
}
inline const std::string& Request::_internal_value() const {
  return value_.Get();
}
inline void Request::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Request::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Request::release_value() {
  // @@protoc_insertion_point(field_release:tutorial.Request.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Request::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:tutorial.Request.value)
}

// -------------------------------------------------------------------

// DataMessageResp

// repeated .tutorial.Request requests = 1;
inline int DataMessageResp::_internal_requests_size() const {
  return requests_.size();
}
inline int DataMessageResp::requests_size() const {
  return _internal_requests_size();
}
inline void DataMessageResp::clear_requests() {
  requests_.Clear();
}
inline ::tutorial::Request* DataMessageResp::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:tutorial.DataMessageResp.requests)
  return requests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Request >*
DataMessageResp::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:tutorial.DataMessageResp.requests)
  return &requests_;
}
inline const ::tutorial::Request& DataMessageResp::_internal_requests(int index) const {
  return requests_.Get(index);
}
inline const ::tutorial::Request& DataMessageResp::requests(int index) const {
  // @@protoc_insertion_point(field_get:tutorial.DataMessageResp.requests)
  return _internal_requests(index);
}
inline ::tutorial::Request* DataMessageResp::_internal_add_requests() {
  return requests_.Add();
}
inline ::tutorial::Request* DataMessageResp::add_requests() {
  // @@protoc_insertion_point(field_add:tutorial.DataMessageResp.requests)
  return _internal_add_requests();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tutorial::Request >&
DataMessageResp::requests() const {
  // @@protoc_insertion_point(field_list:tutorial.DataMessageResp.requests)
  return requests_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tutorial

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tutorial::Message_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::Message_Type>() {
  return ::tutorial::Message_Type_descriptor();
}
template <> struct is_proto_enum< ::tutorial::Statement_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::Statement_Type>() {
  return ::tutorial::Statement_Type_descriptor();
}
template <> struct is_proto_enum< ::tutorial::ClientMessageResp_RespType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::ClientMessageResp_RespType>() {
  return ::tutorial::ClientMessageResp_RespType_descriptor();
}
template <> struct is_proto_enum< ::tutorial::Request_ReqType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tutorial::Request_ReqType>() {
  return ::tutorial::Request_ReqType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
